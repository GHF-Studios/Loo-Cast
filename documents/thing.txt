!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
Define, Implement, and Deploy two separate universe command systems (packaged as one for convenience): Universe API Commands, and Internal Universe Commands
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!




Leslieghf:


More generally speaking, imagine a Bevy Resource "[MODULE_NAME]Commands", 
which has both public and private (A.K.A. module-internal) methods, 
which's function it is to issue commands for "[MODULE_NAME]". 
Additionally, the public functionalities (A.K.A. the [MODULE_NAME] API) can be wrapped into a lightweight FFI-Safe Wrapper Module, to allow access from any programming language. 
The idea is that the Commands pattern exposes functionality and data in such an abstracted manner, that it can easily be exposed as an FFI-Safe API.
The commands structure has one responsibility: Allow the user to *try to* dispatch any sort of command, and get a future wrapped in a result.
if the user decides to use an invalid ID as a parameter, for example, the method will immediately return a Result::Err.
Otherwise, if these preliminiary checks turn out okay, the actual command logic is enqued in some sort of internal commands processing structure, 
which will schedule and process the command, and any other related enqueued commands, in a dependency-respecting order.
The preliminary checks include, but may not limited to: 
	- Validity(Invalid IDs, invalid dependency IDs, invalid parent IDs, etc. are all things that need to be checked for validity, 
		before even attempting to resolve the referenced data structures, let alone perform operations on them.)
	- Dependency(If you request for an entity to be despawned, while it is already despawned, that constitutes an unmet dependency, 
		that dependency being the fact that the targeted entity's state is "Spawned"; basically a very large state machine.
		To feasibly implement this sort of sophisticated dependency management, I propose a "InfoHierarchy" structure [one for each module, similar to the commands structure itself]. 
		Basically this structure stores the lifecycle and state of any sort of relevant entity, 
		mainly to facilitate the efficient, scalable, and ergonomic querying and mutating of any of these entities[which are registered in the first place. 
		That's why validation comes before dependency resolution; it simply cannot happen without preliminary validation])
The actual command code is required to also return a result. How the actual command code is implemented, is not of the Commands Framework's concern.
If the actual command logic returns Result::Ok, the previously returned future is informed of this, and the asynchronous cycle of that specific command request is closed.
If the actual command logic returns Result::Err, the previously returned future if informed of this, and the asynchronous cycle of that specific command request is closed.

Supposedly, you could use macros to simplify the implementation of such Commands structures, while simultaneously also, at least partially, enforcing this commands framework "rule book".
Supposedly, every instance of a command structure would also have an associated thread pool. Small command strucutres may only need a single thread, while others may require many threads, possibly even the GPU.

Still missing: 
	1. A clearer picture of how commands are executed internally and asynchronously.
	2. A clearer picture of how the complexity of this framework could be abstracted away into a completely separate lightweight FFI-safe wrapper.
	3. A clearer picture of how errors are propagated(A.K.A. handled, logged, and communicated back to the caller), especially in an asynchronous context.
	4. A clearer picture of how you could use macros to simplify the implementation of such Commands structures blablabla.
	5. A clearer picture of the way in which every instance of a command structure would also have an associated thread pool blablabla.




ChatGPT:


The concept you're outlining is a sophisticated system for command processing in the Bevy game engine, emphasizing modularity, error handling, and inter-language compatibility through FFI. Here's a simplified breakdown of your description and the missing elements:
	1. Command Processing Structure: A Bevy Resource, "[MODULE_NAME]Commands," manages command issuing. It checks command validity (e.g., IDs) and enqueues valid commands for execution, respecting dependencies. This design encapsulates module functionality, facilitating FFI exposure.
	2. FFI-Safe Wrapper: The API, abstracted via commands, is wrapped in a lightweight, FFI-safe module. This enables interaction with the Bevy system from various languages, ensuring broad usability.
	3. Error Handling and Asynchronous Execution: Commands return futures wrapped in results. Immediate errors (e.g., invalid IDs) yield Result::Err. Valid commands are processed asynchronously, with outcomes communicated through the future mechanism, ensuring robust error handling and feedback.

Missing Elements:
	1. Internal Execution Details: Clarify how commands are internally processed and executed asynchronously. This involves detailing the internal command queue, its execution logic, and how dependency management is integrated.
	2. FFI Wrapper Abstraction: Elaborate on abstracting the command framework's complexity into an FFI-safe wrapper, ensuring that external users interact with a simplified interface, hiding underlying complexities.
	3. Error Propagation: Define a clear strategy for error handling in asynchronous contexts, including error logging, propagation to the caller, and managing potential inconsistencies in command execution.
	4. Macro Utilization: Explain how macros can simplify the implementation of command structures, enforcing the framework's guidelines and potentially automating repetitive coding patterns, improving developer experience.
	5. Thread Pool Association: Detail how each command structure associates with a thread pool, varying in size based on command complexity. Clarify the decision-making process for thread allocation and how GPU resources might be utilized.

By addressing these missing elements, you'll refine the framework, enhancing its clarity, robustness, and utility in game development with Bevy.




















Reimplement these two methods using the commands system
Two part process:
	- Somehow rearange the internal and external universe api layers so that the chunk/entity info hierarchy finds a suitable spot
	- Add UniverseState and PlayerState (and other states?)
(GlobalUniverseCommands) Implement the chunk/entity info hierarchy as a set of commands, which are public to the universe module only
(LocalUniverseCommands) Implement the chunk loading as a set of commands, which are public to the universe module only

Implement LocalUniverse Metadata and Data
Implement GlobalUniverse Metadata and Data
Wrap Player module into PlayerCommands
Wrap Camera module into CameraCommands
Wrap other modules blablabla 

Implement all command structures properly and comprehensively and check everything for validity