1. Operations Module Overview
	Primitive Operations in Rust:
		Definition:
			Primitive operations are the fundamental, low-level operations implemented in Rust, 
			utilizing the performance advantages of Bevy and Rust's ECS.
		Responsibilities:
			Handle all heavy computational tasks and data-intensive processes.
			Provide an API for Lua to request operations and register callbacks
			which are triggered upon operation completion.
			Execute operations without managing dependencies or sequencing;
			each operation is independent and self-contained.
		Performance Considerations:
			Operations are executed asynchronously, optimized for speed and parallel execution.
			Rust returns an operation ID immediately after a request,
			allowing Lua to track and orchestrate these operations.
	Composite Operations in Lua:
		Definition: 
			Composite operations are higher-level constructs defined entirely within Lua,
			composed of multiple primitive operations orchestrated together.
		Responsibilities:
			Orchestrate primitive operations by defining Lua callbacks,
			which handle the flow of operations.
			Manage composite operations as function references within Lua,
			which are unknown to Rust but can be invoked from Lua when needed.
			Use Lua to manage control flow, branching, and operation dependencies
			through the strategic chaining of callbacks.
		Performance Considerations:
			Lua focuses on lightweight orchestration, leveraging Rust for all intensive tasks.
			Lua primarily deals with operation IDs and minimal data,
			avoiding heavy data transfers between Lua and Rust.
2. Lua Integration and Callback Mechanism
	Operation Requests:
		Lua requests primitive operations through a binding to the Rust API
		provided by the operations manager.
		Composite operations have nothing to do with the Rust API binding,
		they are a seperate feature on top of that binding/lua-side Operations Manager.
		Lua passes parameters and a callback function to be triggered
		when the operation completes.
		Rust handles the execution of the operation, returning an
		operation ID for Luato use in further orchestration.
	Callbacks:
		Lua callbacks are triggered by Rust upon operation completion,
		continuing the flow of composite operations.
		Callbacks can chain further operations, manage flow control,
		and execute additional logic as required.
		Lua defines and manages these callbacks,
		which drive the composite operations without requiring Rust's involvement.
	Data Management:
		Lua primarily handles lightweight identifiers
		like UUIDs to reference operations and data.
		For operations that require data access or manipulation,
		Lua triggers specific Rust operations designed for that purpose,
		ensuring heavy lifting remains in Rust.
3. Rust’s Role in Execution Management
	Operations Manager:
		Definition:
			The operations manager in Rust handles the execution of all requested operations,
			whether primitive or invoked from Lua-defined composite operations.
		API Binding:
			Rust provides an API to Lua, allowing it to
			request operations and register callbacks.
			This API facilitates interactions between Lua and Rust.
		No Dependency Management:
			The operations manager does not manage dependencies or sequencing—
			it's role is purely executional, triggering Lua callbacks upon operation completion.
		Asynchronous Execution:
			Operations are executed asynchronously,
			with Rust ensuring efficient and non-blocking execution.
	Concurrency and Parallelism:
		Rust executes operations concurrently where possible, optimizing for performance.
		Lua abstracts away from concurrency concerns,
		focusing purely on orchestrating operations through callbacks.
4. Composite Operations and Lua’s Role
	Lua-Side Composite Operations:
		Defined entirely in Lua, composite operations are higher-level constructs,
		which orchestrate multiple primitive operations.
		Lua scripts manage these operations through the "Operations" module,
		which keeps track of composite operation definitions and handles execution via callbacks.
		These composite operations are persistent in Lua and can be invoked
		in the game’s lifecycle via Lua hooks into Rust/Bevy systems.
	Execution Contexts:
		Lua hooks into Rust/Bevy systems can invoke both primitive and composite operations.
		Lua operates within worker-thread-esque execution contexts,
		where each context is a self-contained script with its own input and output.
		Lua scripts, while they may involve complex orchestration across Lua and Rust,
		always start and end their execution flow in Rust.
5. Asynchronous Flow and Non-Blocking Operations
	Execution Flow:
		Lua scripts define the flow of operations, potentially moving between Lua and Rust
		multiple times through callbacks and operation requests.
		Despite this back-and-forth,
		Lua scripts always start and conclude within the Rust context,
		ensuring that Rust remains in control of the overall execution.
	Blocking in Lua:
		Lua scripts do block while waiting for operations to complete,
		using callbacks to handle continuation and flow control once an operation is finished.
		The blocking nature of Lua scripts means they wait for operations to complete
		before proceeding to the next step, ensuring sequential logic where necessary.
6. Final Thoughts and Considerations
	Efficiency: 
		The architecture remains efficient,
		with Rust handling all performance-critical tasks
		while Lua orchestrates operations in a simple, organized manner.
	Separation of Concerns:
		Rust handles execution and data-intensive tasks,
		while Lua is focused on orchestrating these tasks
		without dealing with their complexities.
	Flexibility:
		Lua’s ability to invoke both primitive and composite operations
		from within hooks into Rust/Bevy systems provides flexibility in
		how game logic and operations are managed.
