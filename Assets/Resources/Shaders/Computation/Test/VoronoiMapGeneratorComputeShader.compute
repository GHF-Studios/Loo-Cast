// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

struct VoronoiCell
{
    int index;
    int positionX;
    int positionY;
};

struct VoronoiPixel
{
    int positionX;
    int positionY;
    int closestVoronoiCellIndex;
    float distanceToVoronoiCell;
};

int2 textureDimensions;
int2 voronoiCellArrayDimensions;
RWStructuredBuffer<VoronoiCell> voronoiCells;
RWStructuredBuffer<VoronoiPixel> voronoiPixels;

float GetSquaredDistance2D(int2 originPos, int2 targetPos)
{
    return pow(targetPos.y - originPos.y, 2) + pow(targetPos.x - originPos.x, 2);
}

VoronoiPixel CalculateVoronoiPixel(VoronoiPixel voronoiPixel)
{
    int2 pixelPos = int2(voronoiPixel.positionX, voronoiPixel.positionY);
    int voronoiCellAmount = voronoiCellArrayDimensions.x * voronoiCellArrayDimensions.y;
    float closestCellDistance = GetSquaredDistance2D(pixelPos, int2(voronoiCells[0].positionX, voronoiCells[0].positionY));
    int closestCellIndex = 0;

    for (int i = 1; i < voronoiCellAmount; i++)
    {
        float potentialNewShortestDistance = GetSquaredDistance2D(pixelPos, int2(voronoiCells[i].positionX, voronoiCells[i].positionY));
        if (potentialNewShortestDistance < closestCellDistance)
        {
            closestCellDistance = potentialNewShortestDistance;
            closestCellIndex = i;
        }
    }
    voronoiPixel.closestVoronoiCellIndex = closestCellIndex;
    voronoiPixel.distanceToVoronoiCell = sqrt(closestCellDistance);
    return voronoiPixel;
}

[numthreads(32, 32, 1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    int x = id.x;
    int y = id.y;

    voronoiPixels[y * textureDimensions.x + x] = CalculateVoronoiPixel(voronoiPixels[y * textureDimensions.x + x]);
}